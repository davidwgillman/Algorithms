# Ozan Gokdemir
## Workshop 5 



## 3)Time your algorithm on input arrays of size 10,000, 20,000, 40,000, and 80,000 and show the results in a table.

### Time Observations(in milliseconds)

 
10,000 -->  1st test:299      
	    2nd test:226
	    3rd test:223   
	    **Average = 249.3** 



20,000 -->  1st test: 492   
	    2nd test: 470		
	    3rd test: 503
	    **Average = 488.3**  


40,000 -->  1st test:1036     
	    2nd test:1111
	    3rd test:1181   
	    **Average = 1109.3** 

80,000 -->  1st test:2303      
	    2nd test:2180
	    3rd test:2156
	    **Average = 2213**
   

Time Observations With Empirical Growing Rate

   N 	  |  time  | ratio 
 ----     |    ----|   ---- 	
	  |	   |	N/A
10000000  |    249 |    
--------  |  ------|    -----
20000000  |    488 |   1.95
--------  |  ------|   -------
40000000  |   1109 |   2.27
--------  |  ------|   -------
80000000  |    2213|    1.99
--------  |   -----|  ------
	


4) Estimate the running time in the form aNb using the doubling method.

r : runtime.

r = a(N)^b is the formula. In order to find a and b, 

249 = a(10^7)^b   (1)
488 = a(2*10^7)^b (2)  then, 

a = 249/(10^7)^b (derived from equation 1), plug a to equation 2,

488 = (249/(10^7)^b)*(2*10^7)^b
b ~ 0.97 therefore,
a ~ 0.0002

finally,

r = a(N)^b = 0.0002(N)^0.97 (This will give us estimated runtime for any input size.)


5) Write a program to shuffle the array [1,2,3,4] 2,400 times, count how many times each shuffled version of the array
   comes up, and print the results. Show the results.

Note to  the professor: Thank you for allowing me to write my program in Python. I would like to assure you that I could easily write a similar one in Java as well.
I just like code conciseness and for this particular task, Python seemed more appealing to me. In Java, I would use a HashMap instead of a dictionary for the
same task. 

Python Program For Counting: 

```

#random.shuffle() uses Fisher-Yates shuffling algorithm. 

table = dict()
import random

def test():
    for i in range(1,2401):
        nums = [1,2,3,4]
        random.shuffle(nums)
        if(str(nums) in table):
            table[str(nums)]+=1
        else:
            table[str(nums)]=1

    for i in table:
        print(i, table[i])

test()

```

[1, 3, 2, 4] 98
[3, 4, 2, 1] 135
[4, 3, 1, 2] 110
[1, 3, 4, 2] 96
[2, 3, 1, 4] 100
[4, 2, 1, 3] 102
[1, 2, 4, 3] 92
[3, 4, 1, 2] 107
[2, 1, 4, 3] 101
[4, 2, 3, 1] 91
[3, 2, 4, 1] 116
[2, 4, 3, 1] 105
[4, 1, 2, 3] 110
[4, 3, 2, 1] 98
[2, 3, 4, 1] 99
[3, 1, 2, 4] 95
[4, 1, 3, 2] 89
[1, 4, 3, 2] 79
[2, 1, 3, 4] 110
[3, 2, 1, 4] 88
[2, 4, 1, 3] 97
[3, 1, 4, 2] 85
[1, 4, 2, 3] 105
[1, 2, 3, 4] 92

6)*Explain why the invariant in the demo is true: after round i, the array is uniformly shuffled from index 0 to index i. (Hint: use induction on i. 
The largest element in a uniformly shuffled array is equally likely to be in any position.)


Uniformity: This is an expected function in a pseudorandom number generator. It means each value within the specified interval has equal probability to occur in 
a random set. We rely on StdRandom.uniform() function to provide us with this function and generate a random number for us, uniformly. 

Each time we loop in the array, ith element gets swapped with the one in idx which is a randomly generated index. Therefore, uniformity means that each value in 
index 0 up to i has an equal probability for being swapped with a[i]. As clients, we expect that any given swap is uniform since idx is generated by
StdRandom.uniform() function which employes Random class from standard Java library. The uniformity is assured even as i increases because the probability of each
index from 0 to i being the idx decreases to ensure equal probability. Therefore, swapping probability(being assigned to idx) of any index with i is (N-i)/N 












